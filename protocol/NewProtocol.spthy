theory NewProtocol
begin

builtins: hashing, asymmetric-encryption, signing

rule Register_PK:
    [ Fr(~SK) ]
  -->
    [ !Sk($A, ~SK), !Pk($A, pk(~SK)) ]

rule Get_PK:
    [ !Pk(A, PK) ]
  -->
    [ Out(PK) ]

rule Reveal_SK:
    [ !Sk(A, SK) ]
  --[ SKReveal(A) ]->
    [ Out(SK) ]

rule Station_1:
    [ Fr(~ST_SK)
    , !Pk($AP, AP_PK)
    ]
  -->
    [ Station_1($AP, ~ST_SK, AP_PK)
    , Out(aenc(pk(~ST_SK), AP_PK))
    ]

rule Station_2:
    let message = adec(response, ST_SK) in
    [ Station_1(AP, ST_SK, AP_PK)
    , In(response)
    ]
  --[ Handshake(AP, ST_SK)
    , Signature(AP, ST_SK,
      verify(message, pk(ST_SK), AP_PK)) ]->
    []

rule Access_Point:
    let message = adec(request, ~AP_SK) in
    [ !Sk($AP, ~AP_SK)
    , In(request)
    ]
  --[ ProbeResponse($AP, message) ]->
    [ Out( aenc(sign(message, ~AP_SK), message) ) ]

lemma Station_Key_Secrecy:
  "
    not(
      Ex S k #i #j #k.
        Handshake(S, k) @ #i
        & K(k) @ #j
        & Signature(S, k, true) @ #k
      & not(Ex #r. SKReveal(S) @ r)
    )
  "

lemma Station_Handshake:
  "
    ( All S k #i #j. Handshake(S, k) @ #i & Signature(S, k, true) @ #j
       ==>
       ( (Ex #a. ProbeResponse(S, pk(k)) @ a)
       | (Ex #r. SKReveal(S) @ r & r < i)
       )
    )
  "

lemma Station_Handshake_Injectivity:
  "
    ( All S k #i #j. Handshake(S, k) @ #i  & Signature(S, k, true) @ #j
       ==>
       ( (Ex #a. ProbeResponse(S, pk(k)) @ a
           & (All #j. Handshake(S, k) @ #j ==> #i = #j)
       )
       | (Ex #r. SKReveal(S) @ r & r < i)
       )
    )
  "

lemma Station_Access:
  exists-trace
  " Ex S k #i #j #k.
        Handshake(S, k) @ #i
        & ProbeResponse(S, pk(k)) @ #j
        & Signature(S, k, true) @ #k
      & not(Ex #r. SKReveal(S) @ r)
  "

end